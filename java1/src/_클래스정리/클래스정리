	[ JAVA 특징 ]
		
	객체지향 (현실의 사물 또는 사람을 컴퓨터 내의 객체로)
	
	- 100% 객체지향 언어
	- 유니코드 사용
	
	산업화 => 컴퓨터 수요 증가 => 자동화, 대량생산
			
	클래스 : 설계도
	객체 : 설계도 기반으로 만들어진 제품(서로 다른 객체 여러개 생산 가능)
			
	회원 클래스 : 아이디, 비밀번호, 이메일, 전화번호 등등
	객체 : 여러명의 회원
	
	+) 고급언어 -> 기계언어로 번역 (컴파일러)
	
	[ 제품 만들기 ]
	1. 클래스(설계도) ---> 대량 객체 생성 ---> 객체 저장 ---> CRUD
	
	
	
	[ 코드 입력시 규칙 ]
	
	1. 클래스 안에 코드 작성
	2. 시작과 끝 { }
	3. 클래스, 메소드 등을 제외한 코드 끝에 ;
	4. 클래스 내 멤버(변수) 접근 시 .
		ex) 클래스.멤버이름
	5. 키워드(예약어) 제외하고 =>  "" (문자)
	6. main 메소드 안에 있는 코드만 실행 가능
	
	+)	1. 컴퓨터 구조 책
		2. 알고리즘 책 ( 백준 문제 풀기 )
	
	[ 메모리 ] - 저장 장치, 데이터를 저장하는 공간
		1) 변수 -> 메모리를 할당받아 저장하는 공간
			1-1) 변수 <--> 상수
			1-2) 자료형 사용 => new 생략
			
		2) 객체 -> 메모리를 할당받아 저장하는 공간
			2-1) 클래스 기반으로 만들어진 메모리 할당 => new
			
			
	[ 용량단위 ]
		0, 1 : 1비트 => 8비트 => 1바이트		
			
			
	[ 자바 문법 ]
	
	1. 변수의 자료형 : 미리 만들어진 저장 크기 ==> 메모리 효율적인 사용 => 용량 줄이기 => 속도 증가
		1) boolean : 1bit
		2) char : 2byte
			//문자열 String 클래스 사용
		3) byte : 1byte
		4) short : 2byte
		5) int : 4byte (java 기본 자료형)
		6) long : 8byte (* 데이터 뒤에 L 붙이기)
		7) float : 4byte : 실수형 (*기본이 double이기 때문에 뒤에 f 붙이기)
		8) double : 8byte : 실수형 (java 기본 자료형)
		
	2. 형 변환
	 	1) 작은 용량 -> 큰 용량 변환 가능
	 	2) 큰 용량 -> 작은 용량 변화 불가능
	 	3) 강제 형변환 : 큰 용량 => 작은 용량 강제로 변환 (손실)
	 		//int 정수 = (int) 롱형변수;
	 		
	 3. 연산자 : 연산시 사용되는 특수문자 (두개 이상 연산자가 있을 경우 우선순위)
	 	1) 산술 연산자 : +, -, *, /, % ==> 결과 : 값
	 	2) 대입 연산자 : = , += 등..
	 	3) 비교 연산자 : >, >=, <, <=, ==, !=  ==> 결과 : t/f
	 	4) 논리 연산자 : &&, ||, !
	 	5) 증감 연산자 : ++, --
	 	
	 4. 제어문
	 	1) if(논리 t/f){두줄 이상} else
	 		* if {} 안에서 선언되거나 초기화된 값은 {}안에서만 사용가능
	 		==> 지역변수 : 괄호 안에서 선언된 변수
	 	2) switch(key){
	 			case value: break;
	 			default: break;
	 		}
	 
	 5. 반복문
	 	1) while(true){} 무한반복
	 	2) for
	 	3) do ~ while
	 	
	 6. 배열 : 하나의 자료형/클래스의 여러개 변수/객체를 관리
	 	1) 1차원 배열 : 자료형[] 배열명 = new 자료형[길이];
	 	2) 2차원 배열 : 자료형[][] 배열명 = new 자료형[행길이][열길이];
	 
	 7. 상속 : 
		 1) 슈퍼클래스의 멤버를 상속받아 그대로 사용 가능 혹은 재정의 가능(오버라이딩)
		 2) extends 뒤에는 하나의 클래스만 가능하다
		 3) super.멤버 : 슈퍼클래스 멤버에 접근 
		 4) @Override : 슈퍼클래스 멤버 재정의
		 
	 8. 인터페이스 : implements
		 1) 동일한 목적하에 동일한 메소드[기능]을 처리하기 위해 사용
		 2) implements 뒤에는 여러개의 인터페이스 가능
			 - 특징 : 추상메소드를 선언만 하고 실제 정의는 연결된 클래스에서 정의
		 3) @Override : 슈퍼클래스 멤버 재정의
	 
	 9. 접근제한자	
	  - public : 모든 곳에서 접근 가능
	  - protected : 동일한 패키지에서 접근 가능, 상속받은 클래스는 다른 패키지 접근 가능
	  - default : 동일한 패키지 내에서 접근 가능 (생략시 default)
	  - private : 현재 클래스에서만 접근 가능
	 	
	
	10. 스트림 : 입추력 데이터 교환 ( 단위 : 바이트 )  
	
	
	 	
	
	[ 클래스 ] - 처음보는 클래스 찾아보기
	
	1. System 클래스 : 전반적인 시스켐 클래스 제공
		1) System.out : 출력
			1-1) println() : console 출력, 자동 줄바꿈
			1-2) print() : console 출력, 줄바꿈 X
			1-3) printf("형식문자", 데이터) : 데이터 형식 지정
			
			1 2 2 0 0
			
	2. Scanner 클래스 : 입력 클래스
		1) nextInt() : 객체내 저장된 데이터를 읽어오는 메소드
		
		
	3. String 클래스 : 문자열 클래스
		1) 클래스이기는 하지만 new String() 생략 가능
		2) 한글자당 2바이트
		3) 문자열.getBytes() : 문자열을 바이트로 변환
		4) new String(byte) : 바이트를 문자열로 변환
		5) .split("구분자") : 구분자를 기준으로 분해 => 배열
		
	4. Random 클래스 : 난수 클래스
		1) .nextInt(k) : 0~(k-1) 까지 난수(정수) 발생
		2) .nextInt(k)+n : n~(k-1) 까지 난수 발생
		
	5. ArrayList<> : 컬렉션 프레임워크 중 하나 => 여러개 변수/객체 관리
		1) 배열과 동일하지만 더 다양한 메소드 제공
			1-1) 리스트명.add(객체명) : 객체를 리스트에 저장
			1-2) 리스트명.get(인덱스) : 해당 인덱스 객체 호출
			1-3) 리스트명.size() : 리스트 총 객체 수
			1-4) 리스트명.remove :  해당 인덱스의 객체 삭제
				=> 객체 삭제시 객체 인덱스 당겨짐
			1-5) 자주 사용되는 메소드
				- 리스트.add(객체명);
				- 리스트.get(인덱스);
				- 리스트.remove(인덱스);
				- 리스트.size();
				- 리스트.clear();	
		2) ArrayList<리트에 담을 클래스명> 리스트명 = new ArrayList<>();
		3) ArrayList와 Vector 차이점 : ArrayList 동기화 X (단일스레드) / Vector 동기화 O (멀티스레드)
		4) ArrayList와 LinkedList 차이점 : ArrayList는 검색 용이, LinkedList 삽입 삭제 빠름


		
	6. Arrays : 배열 클래스
		1) Arrays.sort(배열명) : 정렬(오름차순) 메소드
		2) Arrays.sort(배열명 , Collections.reverseOrder()) => 클래스만 가능 (int -> Integer)
		
		
	7. 파일 입출력 클래스
		1) FileOutputStream : 파일 쓰기 클래스
			*생성자에 true가 있으면 이어쓰기, 없으면 새로쓰기
			1-1) 객체.write(바이트)
				ex) outputStream.write(content.getBytes());
		2) FileInputStream : 파일 읽기 클래스
			1-1) 객체.read(바이트)
				ex) byte[] byteArr = new byte[1024]; //1kb
					inputStream.read(byteArr);
	
	8. 날짜 관련 클래스
		1) Date 클래스 : 시스템 날짜 / 시간
		2) SimpleDateFormat 클래스 : 날짜형식 클래스
		3) Calendar 클래스 : 달력 클래스 (날짜/시간)
			3-1) .get(필드) => calendar.get(calendar.YEAR)
			3-2) Calendar.getInstance(); => 현재 달력 가져오기
		4) ZonedDateTime 클래스 : 협정시간 클래스 
		
	9. List : 순서(인덱스) 기준으로 저장
		1. ArrayList : 동기화 X
		2. Vector : 동기호 O
		3. LinkedList

	11. Set	: 순서 없는 저장
	 	1. HashSet
	 	
	12. Map : 키, 값 => 한쌍
		1. HashMap : 동기화 X
		2. HashTable : 동기화 O
		
		
		
		
	git : 소스 코드 저장소
	
	1. window -> show view -> other -> git -> git repositories -> clone a git repositories ->url 복사 후 복붙
	2. 프로젝젝트 우클릭 -> team -> share project -> 레파지토리 선택
	3. team -> commit -> + -> message -> commit and push
	
	깃 끌어오기
	1. window -> show view -> other -> git -> git repositories -> clone a git repositories ->url 복사 후 복붙
	2. Working Tree -> 프로젝트 우클릭 -> import project
	
	
		
		
	//과제 메일 : itdanja@kakao.com
	// 회원제 게시판
		1. 회원 클래스 => 회원 목록 리스트
			회원번호 : 아이디, 비밀번호, 이름, 연락처
			회원 생성자 : 선택
			회원 메소드 : 회원가입, 로그인 ,회원탈퇴 , 회원수정
			
		2. 게시판 클래스 => 회원 게시물 목록 리스트
			게시판 : 제목, 내용, 작성자[로그인된 아이디], 작성일, 조회수
			게시판 생성자 : 선택
			게시판 메소드 : 글쓰기, 글 출력, 글 상세보기, 글삭제 글 수정
		3. 프로그램 클래스 (main이 속해 있는 클레스)
			1. 메뉴 생성
				1. 회원가입 (아이디 중복제거)
				2. 로그인
				3. 종료
			2. 로그인 성공 시 
				- 모든 게시물의 커뮤니티 출력
				1. 회원목록
				2. 글쓰기
				3. 글 상세보기
			3. 글보기 했을 때
				1. 로그인한 사용자와 글 작성자가 동일한 경우에만 글삭제, 글수정
			4. 로그아웃
				
		
		
	// 과제 11일차, 12일차, 13일차
	// ATM 프로그램 만들기
	1. ATM 인터페이스
		계좌등록 입금 출금 잔고확인
	2. 계좌 클래스 - 슈퍼클래스/ATM 인터페이스 연결
		필드 : 계좌번호[식별], 계좌비밀번호, 계좌주, 이메일, 금액
	3. 은행 3개 정보 클래스 생성 - 서브클래스 ( 계좌 클래스 상속 )
		1. 필드 : 은행코드
	4. 하나의 리스트에 모든 계좌를 저장하고 관리하기
	- 파일 입출력
	4. 프로그램 시작시 파일로 불러오기
	5. 계좌 등록시 리스트에 저장된 데이터 파일에 저장

	
			